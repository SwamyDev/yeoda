<img align="right" src="./docs/imgs/yeoda_logo.png" height="300" width="435">

# yeoda
[![Build Status](https://travis-ci.org/TUW-GEO/yeoda.svg?branch=master)](https://travis-ci.org/TUW-GEO/yeoda)
[![Build Status](https://coveralls.io/repos/TUW-GEO/yeoda/yeoda.png?branch=master)](https://coveralls.io/r/TUW-GEO/yeoda?branch=master)
[![Build Status](https://badge.fury.io/py/yeoda.svg)](https://badge.fury.io/py/yeoda)
[![Build Status](https://readthedocs.org/projects/yeoda/badge/?version=latest)](https://yeoda.readthedocs.io/en/latest/?badge=latest)


*Earth Observation (EO) data, I must read.*

## Description

*yeoda* stands for **y**our **e**arth **o**bservation **d**ata **a**ccess and provides lower and higher-level data cube 
classes to work with well-defined and structured earth observation data. These data cubes allow to filter, split and load data independently from the way the data is structured on the hard disk.  
Once the data structure is known to *yeoda*, it offers a user-friendly interface to access the data with the aforementioned operations.
Internally, the package relies on functionalities provided by [*geopathfinder*](https://github.com/TUW-GEO/geopathfinder) 
(filepath/filename and folder structure handling library), [*veranda*](https://github.com/TUW-GEO/veranda) (IO classes and higher-level data structure classes for vector and raster data)
and [*geospade*](https://github.com/TUW-GEO/geospade) (raster and vector geometry definitions and operations).
Moreover, another very important part of *yeoda* is work with pre-defined grids like the [*Equi7Grid*](https://github.com/TUW-GEO/Equi7Grid) or the [*LatLonGrid*](https://github.com/TUW-GEO/latlongrid).
These grid packages can simplify and speed up spatial operations to identify tiles/files of interest (e.g, bounding box request by a user).

## Examples
The following examples shall help to understand what the package is able to accomplish 
 and how you can use the interface *yeoda* offers to access and play around with your data.
### Setting up a data cube
In simple words, *yeoda* is a filename based data cube tool, which means that it tries to interpret the data structure via the filename.
In the future it will be also possible to create a data cube based on metadata or dataset attributes. To define a filenaming convention, 
*geopathfinder* can be used. Each (existing) filenaming convention has a ``create_[naming_convention]_filename(...)`` function to create a Python object, 
which can be handled like a dictionary to access parts of the filename. 

First, to setup a data cube, you need to prepare some input attributes:
  * A list of filepaths with the same extension (``filepaths``). Currently GeoTIFF and NetCDF files are supported as default by *veranda*.
  * A list of dimensions you want you work with. The dimension names relate to the keys defined by filenaming convention, e.g.:
    ``dimensions = ['time', 'var_name', 'pol']``
  * A function to create a Python object/class instance representing a filenaming convention, e.g.:
    ``smart_filename_creator = create_sgrt_filename``
  * A grid/tiled projection system, which is a class instance of ``pytileproj.base.TiledProjection`` being inherited to a grid package, e.g. *Equi7Grid*:
    ``grid = Equi7Grid(10).EU``
    
You can then initiate a data cube object with the ``EODataCube`` class:
```
dc = EODataCube(filepaths=filepaths, smart_filename_creator=smart_filename_creator,
                dimensions=dimensions, grid=grid)
```
We have also prepared some higher-level data cubes, especially designed to work with (backscatter) products generated by the research group Remote Sensing of the GEO Department at TU Wien (TUWGEO).
To work with preprocessed data you can use the classes ``SIG0DataCube`` for sigma nought and ``GMRDataCube`` for radiometric terrain flattened gamma nought data.
On the value-added data side, ``SSMDataCube`` allows you to access the TUWGEO SSM data.
### Data cube operations
Now we can use our initialised data cubes to work with our data.
*yeoda* uses a *GeoPandas* dataframe to store the filename and geometry information internally.
On top of that, data cube functions where defined to filter, split, sort, align, etc. the data. 
It has to be noted that most functions have a keyword argument ``in_place``. 
If it is set to true, the original object will be overwritten. 
If not, a new data cube object will be returned.
In the next sections some of these functions will be shortly described.
#### Renaming a dimension
If you have to work with a pre-defined naming convention in *geopathfinder* (e.g. the SGRT naming convention) 
and if you do not agree with the naming of the filename parts/dimensions, you can still rename dimensions afterwards:
```
dimensions_map = {'tile_name': 'tile'}
dc.rename_dimension(dimensions_map, in_place=True)
```
In the example above, the dimension "tile_name" was renamed to "tile".
#### Adding a dimension
You can simply add new filepath-dependent values (e.g. file size, cloud coverage, ...) along a new dimension (e.g. named "new_dimension")
with a few lines of code:
```
values = ... # list containing values equal to len(dc)
dc.add_dimension("new_dimension", values, in_place=True)
``` 
#### Sorting along a dimension
Sorting along a dimension can be accomplished with:
```
dc.sort_by_dimension('time', ascending=True, in_place=True)
``` 
All rows with respect to the values along "time" are now sorted in ascending order.
#### Filter by metadata
If you have stored metadata attributes in you NetCDF or GeoTIFF files, you can also filter the data cube by certain attributes.
```
metadata = {'creator': 'me'}
dc.filter_by_metadata(metadata, in_place=True)
``` 
After executing the code above, ``dc`` only stores file where a metadata attribute "creator" is equal to "me".
#### Filter by dimension
A very important function is ``filter_by_dimension``, which accepts a list of values and expressions to filter the data along a dimension.
Expressions is a list having the same length as 
```
metadata = {'creator': 'me'}
dc.filter_by_metadata(metadata, in_place=True)
``` 
#### Split by dimension
``split_by_dimension`` works very similar to ``filter_by_dimension``, but now all filtered values are also split up into new data cubes.
### Loading data
## Limitations and Outlook
At the moment the functionality of *yeoda* is limited in terms of flexibility with different file types, bands and 
tiles, e.g. you can only load data from one tile and one band. This will change in the future by allowing to load data also independent from tile boundaries, bands and file types.
Most changes will take place in *veranda* and *geospade*, so the actual interface to the data given by *yeoda* should stay approximately the same.
## Installation
The package can be either installed via pip or if you solely want to work with *yeoda* or contribute, we recommend to 
install it as conda environment.
### pip
To install *yeoda* via pip in you own environment, use:
```
pip install yeoda
```
### conda
The packages also comes along with an own conda environment (``conda_env.yml``). 
This is especially recommended if you want to contribute to the project.
The following script will install miniconda and setup the environment on a UNIX
like system. Miniconda will be installed into ``$HOME/miniconda``.
```
wget http://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh
bash miniconda.sh -b -p $HOME/miniconda
export PATH="$HOME/miniconda/bin:$PATH"
conda env create -f conda_env.yml
source activate yeoda
```
This script adds ``$HOME/miniconda/bin`` temporarily to the ``PATH`` to do this
permanently add ``export PATH="$HOME/miniconda/bin:$PATH"`` to your ``.bashrc``
or ``.zshrc``.

For Windows, use the following setup:
  * Download the latest [miniconda 3 installer](https://docs.conda.io/en/latest/miniconda.html) for Windows
  * Click on ``.exe`` file and complete the installation.
  * Add the folder ``condabin`` folder to your environment variable ``PATH``. 
    You can find the ``condabin`` folder usually under: ``C:\Users\username\AppData\Local\Continuum\miniconda3\condabin``
  * Finally, you can set up the conda environment via:
    ```
    conda env create -f conda_env.yml
    source activate yeoda
    ```
    
After that you should be able to run 
```
python setup.py test
```
to run the test suite.

## Contribution
We are happy if you want to contribute. Please raise an issue explaining what
is missing or if you find a bug. We will also gladly accept pull requests
against our master branch for new features or bug fixes.
If you want to contribute please follow these steps:

  * Fork the *yeoda* repository to your account
  * Clone the *yeoda* repository
  * Make a new feature branch from the *yeoda* master branch
  * Add your feature
  * Please include tests for your contributions in one of the test directories.
    We use *py.test* so a simple function called ``test_my_feature`` is enough
  * Submit a pull request to our master branch